1. 获取文件 `re` ，先放到 `exeinfope` 中判断，发现有 `upx壳`
![[BUUCTF GUET-CTF2019 re1 1.png]]

2. 用 `upx` 工具脱壳
![[BUUCTF GUET-CTF2019 re1 2.png]]

3. 再用 `exeinfope` 查看，发现已经成功脱壳，并且文件为 `64位ELF文件`
![[BUUCTF GUET-CTF2019 re1 3.png]]

4. 将文件用 `IDA Pro` 打开查看，先用 `Shift + F12` 查看字符串
![[BUUCTF GUET-CTF2019 re1 4.png]]

5. 发现一个 `input flag` ，进入查看
![[BUUCTF GUET-CTF2019 re1 5.png]]

6. `Ctrl + x` 查看交叉引用，发现主函数
![[BUUCTF GUET-CTF2019 re1 6.png]]

7. 发现 `if` 判断语句，若判断正确，则输出 `Correct!` ，只要解决判断逻辑，即可获得 `flag`
8. 进入判断函数 `sub_4009AE` ，查看判断逻辑，发现判断逻辑简单明了，只要字符串 `a1` 的各个字符满足各种条件，即可满足判断条件
![[BUUCTF GUET-CTF2019 re1 7.png]]

9. 根据判断逻辑，编写代码
``` python
a1 = ""
a1 += chr(int(166163712 / 1629056))
a1 += chr(int(731332800 / 6771600))
a1 += chr(int(357245568 / 3682944))
a1 += chr(int(1074393000 / 10431000))
a1 += chr(int(489211344 / 3977328))
a1 += chr(int(518971936 / 5138336))
a1 += "?"
a1 += chr(int(406741500 / 7532250))
a1 += chr(int(294236496 / 5551632))
a1 += chr(int(177305856 / 3409728))
a1 += chr(int(650683500 / 13013670))
a1 += chr(int(298351053 / 6088797))
a1 += chr(int(386348487 / 7884663))
a1 += chr(int(438258597 / 8944053))
a1 += chr(int(249527520 / 5198490))
a1 += chr(int(445362764 / 4544518))
a1 += chr(int(981182160 / 10115280))
a1 += chr(int(174988800 / 3645600))
a1 += chr(int(493042704 / 9667504))
a1 += chr(int(257493600 / 5364450))
a1 += chr(int(767478780 / 13464540))
a1 += chr(int(312840624 / 5488432))
a1 += chr(int(1404511500 / 14479500))
a1 += chr(int(316139670 / 6451830))
a1 += chr(int(619005024 / 6252576))
a1 += chr(int(372641472 / 7763364))
a1 += chr(int(373693320 / 7327320))
a1 += chr(int(498266640 / 8741520))
a1 += chr(int(452465676 / 8871876))
a1 += chr(int(208422720 / 4086720))
a1 += chr(int(515592000 / 9374400))
a1 += chr(int(719890500 / 5759124))

print(a1)
```

10. 需要注意，`a1[16]` 和 `a1[17]` 的判断顺序式反过来的 ，`a1[6]` 在判断函数中不存在，需要遍历尝试，先用 `?` 代表，最后结果为 `1`
11. 提交 `flag`