**格式化字符串**（**format string**）是一些程序设计语言的输入/输出库中能将字符串参数转换为另一种形式输出的函数。例如C、C++等程序设计语言的 `printf` 函数，

格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数

格式化字符串中转换说明以外的其它字符原样输出，而转换说明用于把随后对应的 0 个或多个函数参数转换为相应的格式输出

格式字符串漏洞最初被认为是无害的，但它可用于使程序崩溃或执行有害代码

该问题源于在某些执行格式化的C函数中使用未经检查的用户输入作为格式字符串参数。恶意用户可能会构造特殊的输入从而打印调用堆栈或内存中其他位置的数据，也可以将任意数据写入任意位置

格式化字符串在利用的时候主要分为三个部分

- 格式化字符串函数
- 格式化字符串
- 后续参数
## 格式化字符串函数

常见的格式化字符串函数有

- 输入
	- `scanf`
- 输出
	- `printf`
	- `fprintf`
	- `vprintf`
	- `vfprintf`
	- `sprintf`
	- `snprintf`
	- `vsprintf`
	- `vsnprintf`
	- `setproctitle`
	- `syslog`
	- `err`
	- `verr`
	- `warn`
	- `vwarn`
	- ...

## 格式化字符串格式

格式化字符串中的 **占位符** 用于指明输出的参数值如何 **格式化**

**格式化占位符**（**format placeholder**）的语法如下

```
%[parameter][flags][field width][.precision][length]type
```

其中各参数的含义如下
##### Parameter
**Parameter** 可以忽略，但如果一个占位符使用了 `parameter` ，则其他所有占位符也 **必须使用** `parameter`

| 字符   | 描述                         |
| ---- | -------------------------- |
| `n$` | 表示为第几个参数，可以使参数输出多次，以不同顺序输出 |
##### Flags
**Flags** 可以为 0 个或多个

| 字符  | 描述                                                                                                                                             |
| --- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| `+` | 总是表示有符号数值的 `+` 或 `-` 号<br>缺省情况是忽略正数的符号<br>仅适用于数值类型                                                                                             |
| 空格  | 使得有符号数的输出如果没有正负号或者输出0个字符，则前缀1个空格<br>如果空格与'+'同时出现，则空格说明符被忽略。                                                                                    |
| `-` | 左对齐<br>缺省情况是右对齐。                                                                                                                               |
| `#` | 对于 `g` 与 `G` ，不删除尾部 0 以表示精度<br>对于 `f` , `F` , `e` , `E` , `g` , `G` , 总是输出小数点<br>对于 `o` , `x` , `X` , 在非0数值前分别输出前缀 `0` , `0x` 和 `0X`表示数制       |
| `0` | 如果 **width** 选项前缀为 `0`，则在左侧用`0`填充直至达到宽度要求。例如`printf("%2d", 3)`输出" `3`"，而`printf("%02d", 3)`输出"`03`"。<br>如果 `0` 与 `-` 均出现，则 `0` 被忽略，即左对齐依然用空格填充 |
|     |                                                                                                                                                |

##### Field Width

**Field Width** 给出显示数值的最小宽度，典型用于制表输出时填充固定宽度的表目

- 实际输出字符的个数不足域宽，则根据左对齐或右对齐进行填充
- 实际输出字符的个数超过域宽并不引起数值截断，而是显示全部
- 宽度值的前导 `0` 被解释为 `0` 填充标志，如上述
- 前导的负值被解释为其绝对值，负号解释为左对齐标志
- 如果域宽值为 `*` ，则由对应的函数参数的值为当前域宽

##### Precision

**Precision** 通常指明输出的最大长度，依赖于特定的格式化类型

- 对于d、i、u、x、o的整型数值，是指最小数字位数，不足的位要在左侧补0，如果超过也不截断，缺省值为1
- 对于a,A,e,E,f,F的浮点数值，是指小数点右边显示的数字位数，必要时四舍五入或补0；缺省值为6
- 对于g,G的浮点数值，是指有效数字的最大位数；缺省值为6
- 对于s的字符串类型，是指输出的字节的上限，超出限制的其它字符将被截断
- 如果域宽为`*`，则由对应的函数参数的值为当前域宽
- 如果仅给出了小数点，则域宽为0。

##### Length

**Length** 指出浮点型参数或整型参数的长度，可以忽略

>此项Microsoft称为“Size”

| 字符   | 描述                                                                                                                                                       |
| ---- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `hh` | 对于整数类型，`printf` 期待一个从 `char` 提升的 `int` 的整型参数                                                                                                             |
| `h`  | 对于整数类型，`printf` 期待一个从 `short` 提升的 `int` 的整型参数                                                                                                            |
| `l`  | 对于整数类型，`printf` 期待一个 `long` 的整型参数<br><br>对于浮点类型，`printf` 期待一个 `double` 的整型参数<br><br>对于字符串s类型，`printf`期待一个`wchar_t`指针参数。对于字符c类型，`printf`期待一个`wint_t`型的参数。 |
| `ll` | 对于整数类型，`printf`期待一个`long long`尺寸的整型参数。Microsoft也可以使用`I64`                                                                                                |
| `L`  | 对于浮点类型，`printf`期待一个`long double`尺寸的整型参数                                                                                                                  |
| `z`  | 对于整数类型，`printf`期待一个`size_t`尺寸的整型参数                                                                                                                       |
| `j`  | 对于整数类型，`printf`期待一个`intmax_t`尺寸的整型参数                                                                                                                     |
| `t`  | 对于整数类型，`printf`期待一个`ptrdiff_t`尺寸的整型参数                                                                                                                    |

此外，在ISO C99广泛接受前，还有几个平台相关的length选项：

| 字符    | 描述                                                                                                |
| ----- | ------------------------------------------------------------------------------------------------- |
| `I`   | 对于有符号整数类型，`printf`期待一个`ptrdiff_t`尺寸的整型参数。对于无符号整数类型，`printf`期待一个`size_t`尺寸的整型参数。_常见于Win32/Win64平台_ |
| `I32` | 对于整数类型，`printf`期待一个32位（双字）的整型参数。_常见于Win32/Win64平台_                                                |
| `I64` | 对于整数类型，`printf`期待一个64位（四字）的整型参数。_常见于Win32/Win64平台_                                                |
| `q`   | 对于整数类型，`printf`期待一个64位（四字）的整型参数。_常见于BSD平台_                                                        |

ISO C99的头文件包含了许多宏，用于平台独立的`printf`编码。例如：

| 宏        | 定义                                                          |
| -------- | ----------------------------------------------------------- |
| `PRId32` | 等效于 `I32d` (_Win32/Win64_)或 `d`                             |
| `PRId64` | 等效于 `I64d` (_Win32/Win64_)， `lld` (_32位平台_)或 `ld` (_64位平台_) |
| `PRIi32` | 等效于 `I32i` (_Win32/Win64_)或 `i`                             |
| `PRIi64` | 等效于 `I64i` (_Win32/Win64_)， `lli` (_32位平台_)或 `li` (_64位平台_) |
| `PRIu32` | 等效于 `I32u` (_Win32/Win64_)或 `u`                             |
| `PRIu64` | 等效于 `I64u` (_Win32/Win64_)， `llu` (_32位平台_)或 `lu` (_64位平台_) |
| `PRIx32` | 等效于 `I32x` (_Win32/Win64_)或 `x`                             |
| `PRIx64` | 等效于 `I64x` (_Win32/Win64_), `llx` (_32位平台_)或 `lx` (_64位平台_) |

##### Type

**Type** 也称转换说明

| 字符       | 参数                | 描述                                                                                                                            |
| -------- | ----------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| `d`, `i` | `int`             | 参数作为一个十进制整数打印，如果给出了精度而值的位数少于精度位度，前面用 0 填充                                                                                     |
| `u`      | `unsigned int`    | 参数作为一个无符号值打印，使用十进制                                                                                                            |
| `o`      | `unsigned int`    | 参数作为一个无符号值打印，使用八进制                                                                                                            |
| `x`, `X` | `unsigned int`    | 参数作为一个无符号值打印，使用十六进制<br><br>`x` 使用小写字母，`X` 使用大写字母                                                                              |
| `a`, `A` | `unsigned double` | 参数作为一个无符号值打印，使用十六进制，但指数部分使用十进制<br><br>`a` 使用小写字母，`A` 使用大写字母                                                                   |
| `f`, `F` | `double`          | 参数按照常规浮点格式打印，精度字段决定小数点后面的位数，缺省值为 6<br><br>表示无穷与 `NaN` 时，`f` 输出 `inf` , `infinity` 与 `nan` ， `F` 输出 `INF` , `INFINITY` 与 `NAN` |
| `e`, `E` | `double`          | 参数根据指数形式打印，小数点后面的位数由精度字段决定，缺省值为 6<br><br>`e` 使用小写字母，`E` 使用大写字母                                                                |
| `g`, `G` | `double`          | 若参数的指数在闭区间 [-4, 5] 之间，则使用浮点格式打印，否则使用指数格式打印                                                                                    |
| `s`      | `char *`          | 打印一个字符串                                                                                                                       |
| `c`      | `int`             | 把 `int` 参数转为 `unsigned char` 类型输出                                                                                             |
| `p`      | `void *`          | 输出指针值，通常被转换为一串因编译器而异的可打印字符                                                                                                    |
| `n`      | `int *`           | 不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量                                                                                          |
| `%`      | 无                 | 打印一个 `%` 字符                                                                                                                   |
##### 总结

宽度与精度格式化参数可以忽略，或者直接指定，或者用星号"`*`"表示取对应函数参数的值。例如`printf("%*d", 5, 10)`输出"   `10`"；`printf("%.*s", 3, "abcdef")` 输出"`abc`"

如果函数参数太少，不能匹配所有的格式参数说明符，或者函数参数的类型不匹配，将导致未定义（undefined）行为。过多的函数参数被忽略。许多时候，未定义的行为将导致格式化字符串攻击

某些编译器，如 GCC，会静态检查 `printf` 这一类函数的格式化参数并编译警告存在的问题（当使用编译标志 `-Wall` 或 `-Wformat` 时）

GCC 也会对用户自定义的 `printf` 风格函数做静态检查
## 格式化字符串原理

格式化字符串函数根据格式化字符串进行解析，相应的要被解析的参数个数也自然由格式化字符串控制

格式化字符串漏洞的根本原因在于调用格式化字符串函数时，因为格式化字符串要求的参数个数与实际参数个数不匹配导致实际输出了堆栈中本不应输出的数据，从而导致数据泄露

程序编写时对输入内容的不严格过滤导致了格式化字符串漏洞的产出

如正常的格式化字符串

```
printf("Color %s, Number %d, Float %4.2f", "red", 123456, 3.14);
```

会输出

```
Color red, Number 123456, Float 3.14
```

对于该示例，在进入 `pritf` 函数之前，栈上的布局由高到低（既从栈底到栈顶）地址依次为

```
[之前入栈的其他值]
3.14
123456
字符串 "red" 所在的地址
格式化字符串 "Color %s, Number %d, Float %4.2f" 所在的地址
```

在进入 `printf` 函数之后，函数首先获取第一个参数，既格式化字符串，一个一个读取其字符，此时会遇到两种情况

- 当前字符不是 `%` ，直接输出到相应标准输出。
- 当前字符是 `%` ， 继续读取下一个字符
    - 如果没有字符，报错
    - 如果下一个字符是 `%` ， 输出 `%`
    - 否则根据相应的字符，获取相应的参数，对其进行解析并输出

假设格式化字符串函数如下

```
printf("Color %s, Number %d, Float %4.2f");
```

此时格式化字符串函数并没有提供参数，但是程序会照常运行，也就会将栈上存储格式化字符串地址上面的三个变量分别解析为

1. 解析其地址对应的字符串
2. 解析其内容对应的整形值
3. 解析其内容对应的浮点值

此时就造成了格式化字符串攻击
## 漏洞利用

格式化字符串漏洞主要有五个利用手段

- 使程序奔溃（因为 `%s` 对应的参数地址不合法的概率比较大）
- 栈数据泄露（堆栈读）
- 栈数据覆盖（堆栈写）
- 任意地址内存泄露（任意地址读）
- 任意地址内存覆盖（任意地址写）
### 使程序奔溃

通常来说，利用格式化字符串漏洞使得程序崩溃是最为简单的利用方式，因为我们只需要输入若干个 `%s` 即可

因为栈上不可能每个值都对应了合法的地址，所以总是会有某个地址造成 Linux 内核的保护机制从而造成程序崩溃，使进程收到 `SIGSEGV` 信号

这一利用虽然不能控制程序，但却可以造成程序不可用

### 内存泄露

利用格式化字符串漏洞，我们还可以获取我们所想要输出的内容。一般会有如下几种操作

- 泄露栈内存
    - 获取某个变量的值
    - 获取某个变量对应地址的内存
- 泄露任意地址内存
    - 利用 GOT 表得到 libc 函数地址，进而获取 libc，进而获取其它 libc 函数地址
    - 盲打，dump 整个程序，获取有用信息。


#### 栈数据泄露（堆栈读）

泄露栈内存主要有两个目的

- 获取某个变量的值
- 获取某个变量对应地址的内存

具体操作

- 利用 `%p` 获取对应栈的内容（也可以用 `%x` ，但是要考虑位数的区别）
- 利用 `%s` 获取变量对应地址的内容，但是有零截断，且若是对应的变量不能被解析为字符串地址则程序会崩溃
- 利用 `%n$x` 或 `%n$s` 获取第 `n+1` 处参数的值或字符串

#### 任意地址内存泄露（任意读）
### 内存覆盖

可以使用 `%n` 这个类型参数覆盖内存

基本上构造类似如下的 `payload` 

```
...[overwrite addr] ... %[overwrite offset]$n
```

其中 `...` 表示填充的内容， `overwrite addr` 表示所要覆盖的地址， `overwrite offset` 地址表示所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数

一般来说，内存覆盖的步骤如下

1. 确定覆盖地址
2. 确定相对偏移
3. 进行覆盖

#### 栈数据覆盖（堆栈写）

核心原理是利用 `%n` 对参数进行覆盖

一般做题思路为

1. 确定输入变量的地址
2. 确定变量地址在格式化字符串函数的参数中的排名
3. 构造 `payload`
#### 任意地址内存覆盖（任意写）

##### 覆盖小数字

没必要将地址放在最前面，只需要找到其对应的偏移即可
##### 覆盖大数字

```
hh 对于整数类型，printf期待一个从char提升的int尺寸的整型参数。
h  对于整数类型，printf期待一个从short提升的int尺寸的整型参数。
```

利用 `%hhn` 向某个地址写入单字节，利用 `%hn` 向某个地址写入双字节，分别对每个地址进行写入，根据小端序或大端序进行拼接从而得到最终结果


