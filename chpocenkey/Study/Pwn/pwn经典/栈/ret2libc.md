## 原理

`ret2libc` 控制函数执行 `libc` 中的函数，通常是返回某个函数的 `plt` 处或者函数的具体位置（即函数对应的 `got` 表项的内容）  

一般情况下，会执行 `system("/bin/sh")` 语句，但也可以使用 `execve` 函数或 `/sh` 参数
## 条件

- 存在溢出，且溢出的范围足够大，可以覆盖到 `main` 函数的返回地址
- 存在如 `puts` , `write` 等的打印函数可以被利用。在劫持程序的执行流程后，执行 `puts` , `write` 等函数打印一些已经执行过的函数的真实地址，以便寻找 `libc` 的基地址
## 特点

- 开启了 NX 保护，同时栈不可执行，不能使用 `ret2shellcode`
- 程序本身没有如 `system('/bin/sh')` 的后门函数，不能直接使用 `ret2text`
- 程序中既没 `system` 函数，也没 `/bin/sh` 字符串，需要在 `libc` 库中寻找

由于这种题目需要判断 `libc` 的版本，需要使用到 `LibcSearcher` 这个库

## 解题思路

1. 寻找一个函数的真实地址，以 `puts` 为例，构建合理的 `payload1` ，劫持程序的执行流程，使得程序执行 `puts` 打印得到 `puts` 函数的真实地址，并返回到 `main` 函数重新开始
2. 根据泄露出的 `puts` 函数的真实地址的后三位，判断出 `libc` 库的版本（ `LibcSearcher` 或网站）
3. 根据 `libc` 库的版本确定 `puts` 函数的偏移地址
4. 计算$基地址 = puts 函数的真实地址 - puts 函数的偏移地址$
5. 根据 `libc` 库的版本计算出 `system` 函数和 `'/bin/sh'` 字符串在 `libc` 库中的偏移地址
6. 根据 $真实地址 = 基地址 + 偏移地址$ ，计算出 `system` 函数和 `'/bin/sh'` 字符串的真实地址
7. 构造合理的 `payload2` ，劫持程序的执行流程，执行 `system('/bin/sh')` 从而拿到 `shell`
## 例题

- [[pwn47 32位 ret2libc]]
