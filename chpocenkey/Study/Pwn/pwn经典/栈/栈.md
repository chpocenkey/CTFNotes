## 栈介绍

栈是一种典型的后进先出（LIFO）的数据结构，其主要操作有 **压栈（ `push` ）** 和 **出栈（ `pop` ）**

高级语言在运行时都会被转换为汇编程序，每个程序在运行时都有虚拟地址空间，其中便包含该程序对应的栈，其用于保存函数调用信息和局部变量

程序的栈是从进程地址空间的高地址向低地址增长的

### 寄存器

寄存器用于存放程序执行中

## 函数调用栈

程序的执行过程可以看作连续的函数调用，当一个函数执行完毕后，程序要回到调用指令（ `call` 指令）的下一条指令（紧接 `call` 指令）处继续执行

函数调用过程通常使用堆栈实现，编译器使用堆栈传递函数参数、保存返回地址、临时保存寄存器原有值以备恢复以及存储本地局部变量

不同处理器和编译器的堆栈布局、函数调用方法可能不同，但堆栈的基本概念是一样的

## 栈溢出原理

栈溢出指程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变

### 栈溢出的基本前提

- 程序必须向栈上写入数据
- 写入的数据大小没有被良好地控制

## 栈溢出总结

#### 寻找危险函数

通过寻找危险函数，能够快速确定程序是否可能有栈溢出，以及若存在栈溢出，则栈溢出的位置在哪里

常见的危险函数如下

- 输入
	- `gets` 直接读取一行，忽略 '`\x00`'
	- `scanf`
	- `vscanf`
- 输出
	- `sprintf`
- 字符串
	- `strcpy` 字符串复制，遇到 '`\x00`' 停止
	- `strcat` 字符串拼接，遇到 '`\x00`' 停止
	- `bcopy`

#### 确定填充长度

计算要操作的地址与要覆盖的地址之间的距离

常见的操作方法是使用 IDA，根据其给定的地址计算偏移，一般变量会有以下几种索引方式

- 相对于栈基地址的索引，可以直接通过查看 `ebp` 相对偏移获得
- 相对应栈顶指针的索引，一般也可以通过查看 `esp` 相对偏移获得
- 直接地址索引，相当于直接给定了地址

一般来说，会有如下的覆盖需求

- 覆盖函数返回地址
- 覆盖栈上某个变量的内容
- 覆盖 `.bss` 段某个变量的内容

通过覆盖的方式来直接或间接地控制程序执行流程
## 例题

[[pwn36 后门函数利用]]

