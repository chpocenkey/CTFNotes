# 二进制文件
## 从源代码到可执行文件（以 C 语言为例）
要在操作系统上运行程序，C 语言程序源文件的每条 C 语句都必须被翻译为一系列的低级机器语言指令，这些指令按照可执行目标文件的格式打包，并以二进制文件的形式存放
### 编译原理
**编译器** ：读入以某种语言（源语言）编写的程序，输出等价的用另一种语言（目标语言）编写的程序
编译器可以分为前端（Front end）和后端（Back end）两部分
- **前端** ：与机器无关，其功能是把源程序分解成 **组成要素** 和相应的 **语法结构**，通过 **语法结构** 创建源程序的 **中间表示**，同时收集和源程序相关的信息，存放到 **符号表** 中
- **后端** ：与机器相关，其功能是根据 **中间表示** 和 **符号表信息** 构造 **目标程序**
编译过程可以分为下列 5 个步骤
1. **词法分析（Lexical analysis）** ：读入源程序的字符流，输出为有意义的词素（Lexeme）
2. **语法分析（Syntax analysis）** ：根据各个词法单元的第一个分量来创建树型的中间表示形式，通常是语法树（Syntax analysis）
3. **语义分析（Semantic analysis）** ：使用语法树和符号表中的信息，检测源程序是否满足语言定义的语义约束，同时收集类型信息，用于代码生成、类型检查和类型转换
4. **中间代码生成和优化** ：根据语义分析输出，生成类机器语言的中间表示（如三地址码），然后对生成的中间代码进行分析和优化
5. **代码生成和优化** ：把中间表示形式映射到目标机器语言
### GCC 编译过程
| 编译选项                              | 作用                               |
| --------------------------------- | -------------------------------- |
| `-save-temps`                     | 将编译过程中生成的中间文件保存                  |
| `--verbose`                       | 查看 GCC 编译的详细工作流程                 |
| `-E`                              | 单独执行预处理                          |
| `-S`                              | 将源代码文件或预处理文件生成汇编代码               |
| `-masm=intel`                     | 指定汇编语言的格式为 `intel` 格式            |
| `-fno-asynchronous-unwind-tables` | 生成没有 `cfi` 宏的汇编指令                |
| `-c`                              | 将源代码文件或汇编代码文件生成目标文件              |
| `-static`                         | 指定使用静态链接                         |
| `-g`                              | 在目标文件中添加调试信息，采用 DWARF 格式的形式保存在段中 |
| `-shared`                         | 生成共享库                            |
| `-fpic`                           | 生成与位置无关的代码                       |
GCC 的编译主要包括四个阶段，即 **预处理（Preprocess）** 、 **编译（Compile）** 、**汇编（Assemble）** 、 **链接（Link）**
- **编译器** 对应前两个阶段
- **汇编器** 对应第三个阶段
- **链接器** 对应第四个阶段
#### 预处理阶段
GCC 编译的第一阶段
处理源代码中以 `#` 开始的预处理指令，将其转换后直接插入程序文本中，得到另一个 C 程序，通常以 `.i` 作为文件的扩展名
- 递归处理 `#include` 预处理指令，将对应文件的内容复制到该指令的位置
- 删除所有 `#define` 指令，并且在其被引用的位置递归地展开所有的宏定义
- 处理所有条件预处理指令
- 删除所有注释
- 添加行号和文件名标识
#### 编译阶段
GCC 编译的第二阶段
将 **预处理文件** 进行一系列的词法分析、语法分析、语义分析以及优化，最终生成 **汇编代码文件**，通常以 `.s` 作为文件的扩展名

	GCC 的优化策略将 `printf()` 替换为 `puts()` 以提高性能
#### 汇编阶段
GCC 编译的第三阶段
汇编器根据 **汇编指令** 与 **机器指令** 的对照表进行翻译，将 **汇编代码文件** 汇编成 **目标文件**，通常以 `.o` 作为文件的扩展名

	此时的目标文件是一个可重定位文件 (Relocatable File)，可以使用 objdump 命令来查看其内容

由于此时还未进行链接，对象文件中符号的虚拟地址无法确定
#### 链接阶段
GCC 编译的第四阶段，可分为静态链接和动态链接，**GCC 默认使用动态链接**
链接器将目标文件及其依赖库进行链接，生成可执行文件，操作包括：
- 地址和空间分配（Address and Storage Allocation）
- 符号绑定（Symbol Binding）
- 重定位（Relocation）
链接操作由链接器（.so）完成，结果得到一个静态链接的可执行文件（Executable File），其包含大量的库文件

通过链接操作，目标文件中无法确定的符号地址被修正为实际的符号地址，程序也就可以被加载到内存中正常执行了
## ELF 文件格式
ELF（Executable and Linkable Format），即可执行可链接格式，为 COFF（Common file format）格式的变种，在 Linux 系统上运行，相关定义在 `/usr/include/elf.h` 文件里
### ELF 文件的类型
- 可执行文件（executable file）：经过链接的、可执行的目标文件，通常被称为程序
- 可重定位文件（relocatable file）：由源文件编译而尚未链接的目标文件，通常以 `.o` 作为扩展名，用于与其它目标文件进行链接以构成可执行文件或动态链接库，通常是一段位置独立的代码（Position Independent Code，PIC）
- 共享目标文件（shared object file）：动态链接库文件。用于在链接过程中与其它动态链接库或可重定位文件一起构建新的目标文件，或在可执行文件加载时，链接到进程中作为运行代码的一部分
- 核心转储文件（Core Dump file）：用于进程意外终止时地址进程空间的转储，使用 `gdb` 读取这类文件可以辅助调试和查找程序崩溃的原因
### ELF 文件的结构
在 ELF 文件格式规范中，ELF 文件被统称为 Object file
在审视一个目标文件时，有两种视角可供选择
- **链接视角** ：通过 **节（Section）** 来划分
- **运行视角** ：通过 **段（Segment）** 来划分
#### 链接视角
通常目标文件包含 **代码（.text）** 、 **数据（.data）** 和 **BSS（.bss）** 三个节，除了节外还应包含一个 **文件头（ELF header）**
- **代码节** 用于保存可执行的机器指令
- **数据节** 用于保存已初始化的全局变量和局部静态变量
- **BSS节** 用于保存未初始化的全局变量和局部静态变量
##### 将程序指令和程序数据分开存放的好处
当程序被加载后，数据和指令分别被映射到两个 **虚拟区域**，由于 **数据区域** 对于进程来说是 **可读写的**，而 **指令区域** 对于进程来说是 **只读的**，所以这两个虚拟区域的权限可以被 **分别设置** 为可读写和只读，防止程序的指令被改写和利用
##### ELF 文件头
ELF 文件头（ELF header）位于目标文件最开始的位置，包含描述整个文件的一些基本信息，包括 ELF 文件类型、版本/ABI版本、目标机器、程序入口、段表和节表的位置和长度等
文件头部存在**魔术字符（十六进制 `7f 45 4c 46`，即字符串 `\177ELF`）**，在被映射到内存时可以通过搜索该字符确定映射地址
Elf64_Ehdr 结构体
```
typedef struct {
	unsigned char e_ident[EI_NIDENT];
	Elf64_Half e_type;
	Elf64_Half e_machine;
	Elf64_Word
}
```
##### 节头表
节头表（Section header table）保存目标文件中节的信息，表的每一项都是一个 **Elf64_Shdr 结构体（节描述符）**，记录了节的名字、长度、偏移、读写权限等信息
节头表的 **位置** 记录在 **文件头的 e_shoff 域** 中
节头表对于程序运行并不是必须的，因为它与程序内存布局无关，所以可以去除节头表，以增加反编译器的分析难度

`.data` 节保存 **已经初始化** 的 **全局变量** 和 **局部静态变量**
`.rodata` 节保存 **只读数据**，包括 **只读变量** 和 **字符串常量**
`.bss` 节保存 **未初始化** 的 **全局变量** 和 **局部静态变量** （该节在文件中实际上 **并不存在**，只是为变量 **预留位置**

| 节名                     | 说明                      |
| ---------------------- | ----------------------- |
| `.comment`             | 版本控制信息，如编译器版本           |
| `.debug_XXX`           | DWARF 格式的调试信息           |
| `.strtab`              | 字符串表                    |
| `.shstrtab`            | 节名的字符串表                 |
| `.symtab`              | 符号表                     |
| `.dynamic`             | ld.so 使用的动态链接信息         |
| `.dynstr`              | 动态链接的字符串表               |
| `.dynsym`              | 动态链接的符号表                |
| `.got`                 | 全局偏移量表，用于保存全局变量引用的地址    |
| `.got.plt`             | 全局偏移量表，用于保存函数引用的地址      |
| `.plt`                 | 过程链接库，用于延迟绑定            |
| `.hash`                | 符号哈希表                   |
| `.rela.dyn`            | 变量的动态重定位表               |
| `.rela.plt`            | 函数的动态重定位表               |
| `.rel.text/.rela.text` | 静态重定位表                  |
| `.rel.XXX/.rela.XXX`   | 其它节的静态重定位表              |
| `.note.XXX`            | 额外的编译信息                 |
| `.eh_frame`            | 用于操作异常的 frame unwind 信息 |
| `.init/.fini`          | 程序初始化和终止的代码             |
##### 字符串表
字符串表中包含了以 `null` 结尾的字符序列，用来表示符号名和节名，引用字符串时只需给出字符串序列在表中的偏移即可
字符串表的第一个字符和最后一个字符都是 `null` 字符，以确保所有字符串的开始和终止
##### 符号表
符号表记录了目标文件中所用到的所有符号信息
`dynsym` 保存了引用自外部文件的符号，只能在运行**时**被解析
`symtab` 保存了本地符号，用于调试和链接
前者是后者的子集
目标文件通过一个符号在表中的 **索引值** 来使用该符号
索引值从 0 开始计数，但值为 0 的表项 **不具有实际意义**，它表示未定义的符号
每个符号都有一个 **符号值（symbol value）**，对于变量和函数，该值就是符号的地址
##### 重定位
重定位是连接 **符号定义** 与 **符号引用** 的过程
可重定位文件在构建可执行文件或共享目标文件时，需要把 **节中的符号引用** 换成这些符号 **在进程空间中的虚拟地址**
包含这些转换信息的数据就是 **重定位项（relocation entries）**

#### 运行视角
当运行一个可执行文件时，首先需要将该文件和 **动态链接库** 转载到 **进程空间** 中，形成一个 **进程镜像**。每个进程都拥有 **独立** 的 **虚拟地址空间**，这个空间的 **布局** 由记录在 **段头表** 中的 **程序头（Program header）** 决定，**ELF 文件头的 `e_phoff` 域** 给出了 **段头表的位置**
每个段都包含一个或多个节，相对于对这些节进行 **分组**
随着节的数量的增多，在进行内存映射时产生了空间和资源浪费的问题，通过将不同 **权限** 的节分组，即可同时装载多个节，从而节省资源
通常一个 **可执行文件** 至少有一个 **PT_LOAD 类型的段**，用于描述可装载的节
**动态链接的可执行文件** 包含 **两个** 段，将 `.data` 和 `.text` 分开存放

动态段 PT_DYNAMIC 包含一些 **动态链接器** 所必须的信息，如共享库列、GOT 表和重定位表等
PT_NOTE 类型的段保存了系统相关的 **附加信息**（程序运行时并不需要这些）
PT_INTERP 段将位置和大小信息存放在一个字符串中，是对程序 **解释器位置** 的描述
PT_PHDR 段保存 **程序头表** 本身的位置和大小

在进程镜像中包含、栈、堆、vDSO等空间，这些空间同样通过 **权限** 来进行 **访问控制**，从而保证程序运行时的 **安全**

**动态链接的可执行文件** 装载完成后，还需要进行动态链接才能顺利执行
