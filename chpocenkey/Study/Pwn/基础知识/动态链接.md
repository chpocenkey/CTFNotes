## 起因
**静态链接** 在多个可执行文件包含相同库时，在装载入内存时，两个相同的库也都会被装载进去，造成内存空间的浪费
只要对标准函数做了改动，就需要重新编译整个源文件，造成开发和维护艰难
## 思想
将系统库和子集编写的代码分割为两个独立的模块，在程序真正运行时再将两个模块进行链接，就可以节省磁盘空间，并且内存中的一个系统库可以被多个程序共同使用，还节省物理内存空间
**动态链接** ：在运行或加载时，在内存中完成链接的过程的链接
**共享库（共享对象）**：用于动态链接的系统库
## 位置无关代码
可以加载而无须重定位的代码称为 **位置无关代码（Position-Independent Code，PIC）**，它是 **共享库** **必须具有** 的属性
通过 PIC，一个共享库的代码可以被无限多个进程所共享，从而节约内存资源

### GOT
全局偏移量表（Global Offset Table，GOT）位于数据段的开头，用于保存全局变量和库函数的 **引用**，每个条目占 **8 个字节**，在加载时会进行重定位并填入符号的绝对地址

	由于一个程序（或者共享库）的数据段和代码段的相对距离总是持续不变的，因此，指令和变量之间的距离是一个运行时常量，与绝对内存地址无关

为了引入 RELRO 保护机制，GOT 被拆分为 `.got` 节和 `.got.plt` 节两个部分
- `.got` 节不需要延迟绑定，用于保存 **全局变量引用**，加载到内存后被标记为 **只读**
- `.got.plt` 节需要延迟绑定，用于保存 **函数引用**，具有 **读写** 权限
## 延迟绑定
###### 问题
动态链接是由动态链接器在程序加载时进行的，当需要重定位的符号（库函数）多了之后会影响性能
###### 基本思想
当函数第一次被调用时，动态链接器才进行符号查找、重定位等操作，如果未被调用则不进行绑定
###### 实现
ELF 文件通过 **过程链接表（Procedure Linkage Table，PLT）** 和 **GOT** 的配合来实现延迟绑定，每个被调用的库函数都有一组对应的 PLT 和 GOT
###### PLT
PLT 位于 **代码段 `.plt` 节** ，是一个数组，每个条目占 **16 个字节**
- PLT[0] 用于跳转到动态链接器
- PLT[1] 用于调用系统启动函数 `__libc_start_main()`
- 从 PLT[2] 开始是被调用的各个函数条目
###### GOT
GOT 位于 **数据段 `.got.plt` 节**，也是一个数组，每个条目占 **8 个字节**
- GOT[0] 和 GOT[1] 包含动态链接器在解析函数地址时所需要的两个地址（ `.dynamic` 和 `relor` 条目）
- GOT[2] 是动态链接器 `ld-linux.so` 的如厚点
- 从 GOT[3] 开始就是被调用的各个函数条目，这些条目默认指向对应 PLT 条目的第二条指令，完成绑定后才会被修改为函数的实际地址