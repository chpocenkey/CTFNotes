## 前置知识
- 在 `pwntools` 中，`sendline` 和 `send` 都会发送数据，但是 `sendline`  会发送一行数据，即 `sendline` 会在发送的数据末尾添加一个回车，而 `send` 不会
- 输入的内容先被输入到 **输入缓冲区** 中，再被输入函数读取
## 三个函数
### `read` 函数
**原型**
`read(fd, buf, count)`
**参数**
- `fd` 是文件描述符，用于描述从哪里开始读取
- `buf` 是指针，用于存储读取后存储数据的地址
- `count` 是读入字符的数量
**前提要求**
`fd` 参数为 `0`，表示标准输入， `read` 的内容从输入的缓冲区读取
**读取原理**
输入的内容被输入到 **输入缓冲区** 中，`read` 函数将输入缓冲区中 `count` 限制内的内容读取到指定的 `buf` 中，而超过 `count` 的限制的内容则任然保存在 **输入缓冲区** 中
**回车的影响**
- 当 `count`  的数值大于实际输入的内容的字节数，输入的回车（ASCII 码为 `0A`）会被存入 `buf` 指向的地址（大部分被存储到栈中），此时栈中的数据会受到 `0A` 的干扰
- 当 `count` 的数值小于等于实际输入的内容的字节数，回车被留在了缓冲区，此时若遇到 `gets` 之类的函数，就会干扰到实际上想要输入的数据
### `gets` 函数
使用 `gets()` 函数时，系统会将最后输入的换行符从缓冲区中读取出来，然后舍弃，因此缓冲区中不会遗留换行符，但是 `gets()` 函数需要回车来声明输入的结束，所以 `gets()` 函数需要使用 `sendline` 添加换行符作为输入的结束
`gets` 碰到数组溢出或输入的字节和创建数组的大小一样时，会在发送的数据之后填上 `00`，从而干扰栈中数据
### `scanf` 函数
**原型**
`scanf('%s', c)'
**原理**
`scanf` 从第一个非空白字符（空格、换行符、制表符）开始读入，在按下回车之前，输入的数据都会被存储在输入缓冲区（包括回车），当按下回车之后 `scanf` 就开始从输入缓冲区里面读取数据，直到遇到空白字符，停止读取，而剩下的内容仍保留在输入缓冲区中
但是 `scanf('%s', c)` 需要用 `sendline` 函数发送，若用 `send` 函数会被卡住
## 总结
- `scanf` 和 `gets` 函数都必须使用 `sendline` 来发送，而 `read` 函数可以使用  `send` 发送，且 `read` 用 `send` 来发送数据可以确保万无一失
- `scanf` 用 `sendline` 来发送不会清空回车，回车仍保留在输入缓冲区中，会对之后的输入造成影响，而 `gets` 用 `sendline` 来发送时会清空回车，但是溢出了数组限制的话，会异常地在输入的字符串结尾填入 `00` 存入栈中，此时也可能会覆盖原本栈中的数据