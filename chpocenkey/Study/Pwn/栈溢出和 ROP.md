由于 C 语言对数组引用不做任何边界检查，从而导致缓冲区溢出（buffer overflow）成为一种很常见的漏洞，根据溢出发生的内存位置，通常可以分为 **栈溢出** 和 **堆溢出**
**栈溢出** 由于栈上保存着局部变量和一些状态信息（寄存器值、返回地址等），一旦发生严重的溢出，攻击者就可以通过 **复写返回地址** 来执行 **任意代码**，利用方式包括 `shellcode` 注入、 `ret2libc` 、ROP 等
## 函数调用栈
函数调用栈是一块连续的用来保存函数运行状态的内存区域，调用函数（caller）和被调用函数（callee）根据调用关系堆叠起来，从内存的高地址向低地址增长。这个过程主要涉及三个寄存器：
- `eip` / `rip` 用于存储即将执行的指令地址
- `esp` / `rsp` 用于存储栈顶地址，随着数据的压栈和出栈而变化
- `ebp` / `rbp` 用于存储栈基址，并参与栈内数据的寻址

在 64 位，根据 AMD64 ABI 文档的描述，`rsp` 以下 128 字节的区域被称为 red zone，这是一块被保留的内存，不会被信号或中断所修改，所以叶子函数可以在不调整栈指针（不下移 `rsp` 开辟栈空间）的情况下，使用这块内存保存临时数据。这是一项 **编译优化**

在更极端的 **优化** 下，`rbp` 作为栈基址也可以省略，编译器完全可以使用 `rsp` 来代替，从而减少指令数量
## 危险函数
- `scanf`、`gets` 等输入读取函数
- `strcpy`、`strcat`、`sprintf` 等字符串拷贝函数
## `shellcode` 注入
在没有 NX 保护机制的时候，在栈溢出的同时就可以将 `shellcode` 注入栈上并执行。使输入一直覆盖到调用者的 `ebp` / `rbp`，然后在返回地址处填充上 `shellcode` 的地址，当函数返回时，就会跳到 `shellcode` 的位置
开启了 ASLR，使 `shellcode` 的地址不确定，则可以使用 NOP sled（`\x90\x90`）作为一段滑板指令，当程序跳到这段指令时，就会一直滑到 `shellcode` 执行
## `ret2libc`
开启 NX 保护时，栈上的 `shellcode` 不可执行，此时需要使用 `ret2libc` 调用 `libc.so` 中的 `system("/bin/sh")`，在返回地址覆盖上 `system()` 函数的地址。再添加 `"/bin/sh"` 字符串的地址作为参数
开启了 ASLR，则需要先做内存泄漏，再填充真实地址
## ROP

