计算机中的整数分为有符号整数和无符号整数，通常保存在一个固定长度的内存空间内，它能存储的最大值和最小值都是固定的

| C 数据类型           | 最小值                  | 最大值                  |
| ---------------- | -------------------- | -------------------- |
| // 32 位          |                      |                      |
| `[signed] char`  | -128                 | 127                  |
| `unsigned char`  | 0                    | 255                  |
| `short`          | -32768               | 32767                |
| `unsiged short`  | 0                    | 65535                |
| `int`            | -2147483648          | 2147483647           |
| `unsigned`       | 0                    | 4294967295           |
| `long`           | -2147483648          | 2147483647           |
| `unsigned long`  | 0                    | 4294967295           |
| // 64 位          |                      |                      |
| `[signed] char`  | -128                 | 127                  |
| `unsigned char`  | 0                    | 255                  |
| `short`          | -32768               | 32767                |
| `unsigned short` | 0                    | 65535                |
| `int`            | -2147493648          | 2147483647           |
| `unsigned`       | 0                    | 4294967295           |
| `long`           | -9223372036854775808 | 9223372036854775807  |
| `unsigned long`  | 0                    | 18446744073709551615 |
# 整数安全漏洞
## 整数溢出
如果一个整数用来计算一些敏感数值，就会产生潜在的危险，可能导致栈溢出和堆溢出，从而导致任意代码执行
关于整数的异常情况主要有三种
- **溢出：** 只有有符号数才会发生溢出，同号相加时可能改变符号的值，产生溢出，溢出标志 OF 可检测有符号数的溢出
- **回绕：** 无符号数在如 0-1 时会变成最大的数，如同循环数组一样，进位标志 CF 可检测无符号数的回绕
- **截断：** 将一个较大宽度的数存入一个较小宽度的操作数内，高位发生截断，如 8 字节的数放入 4 字节的变量中，就只剩低位 4 字节的数据
数据转换是一种用于表示赋值、类型强制转换或者计算的结果值的底层数据类型的改变，如果向更大宽度的类型转换，通常会保留数学值；如果向更小宽度的类型转换，会导致高位丢失，具体为以下两种错误：
- 损失值
- 损失符号
整型提升指当计算表达式中包含了不同宽度的操作数时，较小宽度的操作数会被提升到和较大操作数一样的宽度，再进行计算
## 漏洞多发函数
##### `memcpy()`
```
#include <string.h>
void *memcpy(void *dest, const void *src, size_t n);
```
`memcpy()` 函数将 `src` 所指向的字符串中以 `src` 地址开始的前 `n` 个字节复制到 `dest` 所指的数组中，并返回 `dest`。由于它有一个 `size_t` 类型的参数（`size_t` 是无符号整数类型的 `sizeof()` 的结果），常常被误用而导致整数溢出，接着就可能导致缓冲区溢出漏洞
##### `strncpy()`
```
#include <string.h>
char *strncpy(char *dest, const char *src, size_t n);
```
`strncpy()` 函数将从 `src` 所指的内存地址的起始地址开始赋值 `n` 个字节到目标 `dest` 所指的内存地址的起始位置中。同样由于它有一个 `size_t` 类型的参数（`size_t` 是无符号整数类型的 `sizeof()` 的结果），常常被误用而导致整数溢出，接着就可能导致缓冲区溢出漏洞