## 定义

>**汇编语言**（英语：**assembly language**）是任何一种用于电子计算机、微处理器、微控制器，或其他可编程器件的低级语言。在不同的设备中，汇编语言对应着不同的机器语言指令集。一种汇编语言专用于某种计算机系统结构，而不像许多高级语言，可以在不同系统平台之间移植。
>———— 引自 [维基百科](https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80)

汇编语言是一种低级编程语言，它非常接近机器语言。它用于直接控制计算机的硬件，包括CPU、内存和其他外围设备。汇编语言的指令通常对应于机器指令，这些指令是CPU可以直接执行的命令
## 应用领域

汇编语言能够直接访问计算机硬件，所以执行起来比那些高级语言效率高，而且占用资源极少，所以一般用于对运行效率有较高要求的领域，或者说为了突破系统性能的瓶颈而将频繁使用的子程序或程序段用汇编来编写

- 系统内核
- 工业控制
- 驱动程序
- 实时系统
- 核心算法

## 与机器语言、高级语言的关系

**机器语言**

机器语言是用二进制代码表示的、计算机能直接识别和执行的一种机器指令的集合，它具有灵活、直接执行和速度快等特点，但是用机器语言编写程序极其繁琐，编写出来的指令代码可读性差且容易出错

>要用机器语言编写程序，编程人员需首先熟记所用计算机的全部指令代码和代码的涵义。手编程序时，程序员要自己处理每条指令和每一数据的存储分配和输入输出，还需记住编程过程中每步所使用的工作单元处在何种状态。这是一件十分繁琐的工作，编写程序花费的时间往往是实际运行时间的几十倍或几百倍。而且，这样编写出的程序完全是0与1的指令代码，可读性差且容易出错。在现今，除了计算机生产厂家的专业人员外，绝大多数程序员已经不再学习机器语言。
>———— 引自 [维基百科](https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80)

**汇编语言**

汇编语言使用助记符来代替和表示特定低级机器语言的操作，使用汇编语言编写的源代码通过相应的汇编程序将它们转换成可执行的机器代码

汇编语言可以理解为一种映射，机器语言和实际命令一一对应，但是机器语言只有 0 和 1，极其容易出错，所以设计了一种助记符，表示某一命令的同时对应其机器语言，这就是汇编语言

**高级语言**

高级语言是高度封装了的编程语言，使用一般人易于接受的文字来表示，有较高的可读性

用汇编语言编某一功能的时候，连续一段代码都是相同或相似，于是就考虑用一句语言来代替这一段汇编语言，于是就产生了高级语言（C\C++等）
## 汇编语言的风格

汇编语言是任何一种对于电子计算机、微处理器、微控制器，或其他可编程器件的低级语言，在不同的设备中，汇编语言对应着不同的机器语言指令集

一种汇编语言专用于某种计算机系统结构

x86/amd64 汇编指令的两大风格分别是 Intel 汇编和 AT&T 汇编，分别被 Microsoft Windows/Visual C++ 与 GNU/Gas 采用（Gas也可使用Intel汇编风格）

以下简单介绍两种汇编风格的区别，具体信息可以访问 [汇编语言的Wikipedia介绍](https://zh.wikipedia.org/wiki/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80) 获取

| 项目                  | Intel 风格                                                              | AT&T 风格                                   |
| ------------------- | --------------------------------------------------------------------- | ----------------------------------------- |
| 操作数顺序               | 目标操作数在前                                                               | 源操作数在前                                    |
| 寄存器                 | 原样                                                                    | 加 `%` 前缀                                  |
| 立即数                 | 原样                                                                    | 加 `$` 前缀                                  |
| 16 进制立即数            | 用后缀 `B` 和 `H` 分别表示二进制与十六进制，对于 16进制字母开头要加前缀 0                          | 加 `0x` 前缀                                 |
| 访问内存长度的表示           | 前缀 `BYTE PTR` , `WORD PTR` , `DWORD PTR` 和 `QWORD PTR` 分别表示字节、字、双字和四字 | 后缀 `b` , `w` , `l` , `q` 分别表示分别字节、字、双字和四字 |
| 引用全局或静态变量 `var` 的值  | `[var]`                                                               | `var`                                     |
| 引用全局或静态变量 `var` 的地址 | `var`                                                                 | `$var`                                    |
| 引用局部变量              | 基于栈指针 `rsp`                                                           | 基于栈指针 `rsp`                               |
| 绝对寻址                | `[imm]`                                                               | `imm`                                     |
| 间接寻址                | `[reg]`                                                               | `(%reg)`                                  |
| 基址相对寻址              | `[reg + imm]`                                                         | `imm(%reg)`                               |
| 变址寻址                | `[base + index]`                                                      | `(base, index)`                           |
| 变址寻址                | `[base + index + imm]`                                                | `imm(base, index)`                        |
| 比例变址寻址              | `[base + index * scale + imm]`                                        | `imm(base, index, scale)`                 |
| 代码注释                | 单行注释用 `;` 注释内容                                                        | 单行注释用 `;` 注释内容                            |
>这里 `imm` 为立即数， `base` 和 `index` 为寄存器， `scale` 为伸缩量

并不需要完全学习所有汇编指令和所有汇编语言，从一种汇编语言风格可以类推另一种风格，只需要注意其区别
## 寄存器

因为 CPU 的运算的速度远高于内存的读写速度，为了避免被内存的读写速度拖慢，CPU 自带缓存，但是 CPU 缓存还是不够快，所以出现了更快的寄存器

CPU 自带寄存器，用于储存最常用的数据

CPU 优先读写寄存器，再由寄存器跟内存交换数据

### 通用寄存器

通用寄存器是一种通用型的寄存器，用于传送和暂存数据，也可以参与算数逻辑运算，并保存运算结果

所说的 32 位 CPU、64 位 CPU 中的 ”位“，指的是寄存器的大小，32 位 CPU 的寄存器大小为 4 个字节，64 位 CPU 的寄存器大小为 8 字节

| 32 位通用寄存器 | 通用寄存器的作用                                      |
| --------- | --------------------------------------------- |
| EAX       | 累加器，在乘法和除法指令中被自动使用<br>返回值，在 Win32 中一般用作函数的返回值 |
| EBX       | 基地址寄存器，在内存寻址时存放基地址                            |
| ECX       | 计数器，CPU 自动使用 ECX 作为循环计数器，在字符串和循环操作中常用         |
| EDX       | 数据寄存器，常用来放整数除法产生的余数                           |
| ESP       | 堆栈指针计数器，指向上个栈帧的栈顶，ESP 一般不参与算数运算，而是用来寻址堆栈上的数据  |
| EBP       | 指向最上面一个栈帧的地步，EBP 由高级语言用来引用参数和局部变量             |
| EIP       | 存放下一条要执行的指令地址                                 |
| ESI       | 一般在字符串操作时指向源串                                 |
| EDI       | 一般在字符串操作时指向目标串                                |

16 位通用寄存器为

- AX
- BX
- CX
- DX
- SI
- DI
- BP
- SP

其中，前四个 16 位通用寄存器还可以分为高 8 位和低 8 位两个独立的寄存器

![[通用寄存器]]

### 标志寄存器

标志寄存器（EFLAG）有三种作用

- 存储相关指令的某些执行结果
- 为 CPU 执行相关指令提供行为依据
- 控制 CPU 的相关工作方式

标志寄存器中的标志大致可以分为两类

- 状态标志（ `CF` , `ZF` , `SF` , `PF` , `OF` , `AF` ）：用来记录程序运行结果的状态信息
- 控制标志（ `DF` , `IF` , `TF` ）：用于控制处理器执行指令的方式

| 标志   | 作用                                                                                                                            |
| ---- | ----------------------------------------------------------------------------------------------------------------------------- |
| `CF` | 进位标志，当运算结果的最高有效位为进位或借位时， `CF` 置 1，否则置 0                                                                                       |
| `ZF` | 零标志，当运算结果为 0 时， `ZF` 置 1，否则置 0                                                                                                |
| `SF` | 符号标志，当运算结果最高位为 1 时， `SF` 置 1，否则置 0                                                                                            |
| `PF` | 奇偶标志，当运算结果（二进制）中 `1` 的个数为偶数时， `PF` 置 1，否则置 0                                                                                  |
| `OF` | 溢出标志，当算术运算结果有溢出时， `OF` 置 1，否则置 0                                                                                              |
| `AF` | 辅助进位标志，在发生下列情况时， `AF` 置 1，否则置 0：<br>1. 在字操作时，发生低字节向高字节进位或错位时<br>2. 在字节操作时，发生低 4 位向高 4 位进位或借位时                                 |
| `DF` | 方向标志，用于在串操作指令中，控制地址的变化方向<br>`DF` 置 0 时，存储器地址自动增加<br>`DF` 置 0 时，存储器地址自动减少                                                      |
| `IF` | 中断允许标志，用于决定 CPU 是否响应 CPU 外部的可屏蔽中断发出的中断请求<br>`IF` 置 1 时，CPU 可以响应 CPU 外部的可屏蔽中断发出的中断请求<br>`IF` 置 0 时，CPU 不响应 CPU 外部的可屏蔽中断发出的中断请求 |
| `TF` | 陷阱标志，主要用于程序调试，指令系统中没有专门的指令来改变 `TF` 的值<br>`TF` 置 1 时，CPU 进入单步执行方式，即每执行一条指令，产生一个单步中断请求                                          |

### 段寄存器

段寄存器用于存放段的基地址

16 位 CPU 中，段寄存器只有 4 个

| 段寄存器 | 作用                                      |
| ---- | --------------------------------------- |
| `CS` | 指明代码段的起始地址<br>处理器利用 `CS:IP` 取得下一条要执行的指令 |
| `DS` | 指明数据段的起始地址<br>处理器利用 `DS:EA` 存取数据段中的数据   |
| `SS` | 指明堆栈段的起始地址<br>处理器利用 `SS:SP` 操作堆栈顶的数据    |
| `ES` | 指明附加段的起始地址<br>处理器利用 `ES:EA` 存取附加段中的数据   |

32 位 CPU 中，段寄存器从 4 个扩展为 6 个

- `CS`
- `DS`
- `SS`
- `ES`
- `FS`
- `GS`

## 寻址方式

### 指令

指令由操作码和操作数两个部分组成

操作码用于说明计算机要执行哪种操作，用一个唯一的助记符表示，对应着机器指令的一个二进制编码

操作数是指令执行的参与者，是操作的对象，通常指令可以有 0 ~ 4 个操作数，指令中的操作数是一个具体的数值，可以是存放数据的寄存器，或指明数据所在存储位置的存储器地址
### 寻址

寻址方式就是用于获取实际需要的数据的方式

数据通常来自三个地方

- 数据在指令中直接给出
- 数据在寄存器中保存
- 数据在内存中保存
### 常见寻址方式

寄存器相对寻址、变址寻址、基址变址寻址、比例因子寻址
#### 立即数寻址

数据在指令中直接给出，即操作数就是需要处理的数据
#### 寄存器寻址

数据在寄存器中保存，操作数给出寄存器
#### 直接寻址

数据在内存中保存，操作数给出数据所在的内存地址
#### 寄存器间接寻址

数据在内存中保存，数据保存的内存地址被存储到寄存器中，操作数给出寄存器

## 堆栈

堆栈（栈）是一个“后进先出LIFO”（或者说是“先进后出FILO”）的内存区域，位于堆栈段中，它的本质还是一块内存，堆栈的内存分配是由高地址向低地址延伸的；SS段寄存器记录其段地址。  
堆栈只有一个出口，即当前栈顶，用堆栈指针寄存器ESP指定，栈顶是地址较小的一端（低端），栈底不变。  

**用途**

- 用于储存临时的数据  
- 高级语言中参数的传递

**基本操作**

- `PUSH` （进栈）向堆栈中压入数据，然后修改栈顶指针 `ESP` 寄存器的值
- `POP` （出栈）将堆栈中数据存储到寄存器或内存，然后修改栈顶指针 `ESP` 的值

## 常见汇编指令

### 数据传递指令

#### 1. `mov` 指令

```
mov [目的操作数], [源操作数]
```

`mov` 指令相当于赋值操作

`mov` 指令可以实现寄存器与寄存器之间、寄存器与内存之间、寄存器与立即数之间、寄存器与立即数之间、内存与立即数之间的数据传递

**注意**

- 内存与内存之间无法直接传递数据
- 目的操作数不能为立即操作数
- 两个操作数的宽度必须一致

#### 2. `xchg` 指令

```
xchg [目的操作数], [源操作数]
```

`xchg` 指令用于交换两个操作数的数据

`xchg` 指令可以实现寄存器与寄存器之间、寄存器与内存之间的数据传递

**注意**

- 内存与内存之间不能进行数据交换

#### 3. `lea` 指令

```
lea [目的寄存器]，[地址表达式]
```

`lea` 指令用于装入有效地址

`lea` 指令将内存单元的地址送至指定的寄存器

**注意**

- `lea` 指令的操作数虽然也是内存单元，但是它获取到的是内存单元的地址，而不是内存单元中的数据

### 逻辑运算指令

#### 1. `and` 指令

```
and [目的操作数], [源操作数]
```

`and` 指令执行按位与运算，结果送入目的操作数

对应的两个位同时为 1 时，结果为 1，否则为 0

**注意**

- 目的操作数可以是寄存器或内存地址
- 源操作数可以是立即数、寄存器或内存地址

#### 2. `or` 指令

```
or [目的操作数], [源操作数]
```

`or` 指令用于执行按位或运算，结果送入目的操作数

对应的两个位同时为 0 时，结果为 0，否则为 1

**注意**

- 目的操作数可以是寄存器或内存地址
- 源操作数可以是立即数、寄存器或内存地址

#### 3. `not` 指令

```
not [目的操作数]
```

`not` 指令用于执行按位取反运算，结果送入目的操作数

对应的位为 0 时，结果为 1，否则为 0

**注意**

- 目的操作数必须是寄存器或内存地址

#### 4. `xor` 指令

```
xor [目的操作数], [源操作数]
```

`xor` 指令用于执行按位异或运算，结果送入目的操作数

对应的两个位相同时，结果为 0，否则为 1

**注意**

- 目的操作数可以是寄存器或内存地址
- 源操作数可以是立即数、寄存器或内存地址

### 算数运算指令

#### 1. `add` 指令

`add` 指令用于执行加法运算

将源操作数与目的操作数相加，相加的结果储存在目的操作数中

**注意**

- 操作数的长度必须相同

#### 2. `sub` 指令

`sub` 指令用于执行减法运算

将源操作数与目的操作数相减，相减的结果储存在目的操作数中

**注意**

- 操作数的长度必须相同

#### 3. `adc` 指令

`adc` 指令用于执行带进位的加法运算，类似于 `add` 指令

将源操作数与目的操作数相加，再加上标志寄存器 `CF` 的值，将相加的结果储存在目的操作数中

#### 4. `sbb` 指令

`sbb` 指令用于执行带皆为的减法运算，类似于 `sub` 指令

将源操作数与目的操作数相减，再减上标志寄存器 `CF` 的值，将相减的结果储存在目的操作数中

#### 5. `inc` 指令

`inc` 指令用于执行自增运算

对目的操作数进行加一操作，将结果储存在目的操作数中

#### 6. `dec` 指令

`dec` 指令用于执行自减运算

对目的操作数进行减一操作，将结果储存在目的操作数中

### 堆栈操作指令

#### 1. `push` 指令

入栈
#### 2. `pop` 指令

出栈
#### 3. `pushad` 指令

全部入栈
#### 4. `popad` 指令

全部出栈
### 转移指令

#### 1. `jmp` 指令

`jmp` 指令是一条无条件转移指令，只要遇到 `jmp` 指令，即跳转到相应的地址进行执行

`jmp` 指令通过修改 `EIP` 寄存器的值，从而使指令转移到其他地址继续执行
#### 2. `jcc` 指令集

条件转移指令有多条，通常称条件转移指令为 `jcc` 指令集

`jcc` 指令集决定是否跳转只与 `EFLAG` 标志寄存器有关系

| `jcc` 指令              | 中文含义                           | 检查符号位             |
| --------------------- | ------------------------------ | ----------------- |
| `jz` , `je`           | 若为 0 则跳转<br>若相等则跳转             | `ZF=1`            |
| `jnz` , `jne`         | 若不为 0 则跳转<br>若不相等则跳转           | `ZF=0`            |
| `js`                  | 若为负则跳转                         | `SF=1`            |
| `jns`                 | 若为正则跳转                         | `SF=0`            |
| `jp` , `jpe`          | 若 1 出现次数为偶数则跳转                 | `PF=1`            |
| `jnp` , `jpo`         | 若 0 出现次数为奇数则跳转                 | `PF=0`            |
| `jo`                  | 若溢出则跳转                         | `OF=1`            |
| `jno`                 | 若无溢出则跳转                        | `OF=0`            |
| `jc` , `jb` , `jnae`  | 若进位则跳转<br>若低于则跳转<br>若不高于等于则跳转  | `CF=1`            |
| `jnc` , `jnb` , `jae` | 若无进位则跳转<br>若不低于则跳转<br>若高于等于则跳转 | `CF=0`            |
| `jbe` , `jna`         | 若低于等于则跳转<br>若不高于则跳转            | `ZF=1` 或 `CF=1`   |
| `jnbe` , `ja`         | 若不低于等于则跳转<br>若高于则跳转            | `ZF=0` 或 `CF=0`   |
| `jl` , `jnge`         | 若小于则跳转<br>若不大于等于则跳转            | `SF!=OF`          |
| `jnl` , `jge`         | 若不小于则跳转<br>若大于等于则跳转            | `SF=OF`           |
| `jle` , `jng`         | 若小于等于则跳转<br>若不大于则跳转            | `ZF!=OF` 或 `ZF=1` |
| `jnle` , `jg`         | 若不小于等于则跳转<br>若大于则跳转            | `SF=OF` 且 `ZF=0`  |

下面介绍两个经常与 `jcc` 指令配合使用的指令
##### 1. `cmp` 指令

`cmp` 指令用于对两个操作数进行比较，

`cmp` 指令的比较方式是用目的操作数减源操作数，但结果送入目的操作数，而是影响标志位 `OF` , `SF` , `ZF` , `AF` , `PF` , `CF`

`cmp` 指令被称为 **比较指令** ，常与 `jcc` 指令配合使用

##### 2. `test` 指令

`test` 指令用于执行逻辑与运算，但结果不送入目的操作数，而是影响标志位 `OF` , `SF` , `ZF` , `PF` 和 `CF`

`test` 指令被称为 **测试指令** ，通常用于测试一些条件是否满足，常与 `jcc` 指令配合使用

#### 3. `loop` 指令

`loop` 指令是循环控制指令，需要使用 `ECX` 寄存器来进行循环计数

当执行到 `loop` 指令时，先将 `ECX` 寄存器中的值减1，如果 `ECX` 寄存器中的值大于0，则转移到 `loop` 指令后的地址处，如果 `ECX` 寄存器中的值等于0，则执行 `loop` 指令的下一条指令

#### 4. `call` 指令

`call` 指令是调用过程（函数）的指令，可以修改 `EIP` 寄存器的值，从而使指令转移到其他地址继续执行

与 `jmp` 指令不同的地方是， `call` 指令在修改EIP寄存器的值之前，会将 `call` 指令的下一条指令的地址保存至堆栈，以便在调用过程（函数）执行完之后再返回到原来 `call` 指令处执行下一条指令

#### 5. `ret` 指令

`ret` 指令用于过程（函数）的返回，该指令从堆栈的栈顶中弹出4个字节（32位系统）送入 `EIP` 寄存器中。一般该指令在过程（函数）需要返回的位置或者是过程（函数）的结尾处

`call` 指令调用过程（函数）时会将 `call` 指令的下一条指令压入栈顶，当过程（函数）执行中遇到 `ret` 指令时，会将 `call` 指令压入的指令弹出送入 `EIP` 寄存器中，这样代码的流程就会接着 `call` 指令的下一条指令继续执行

	ret 指令不需要修正堆栈栈顶的位置直接返回，retn 指令则需要修正堆栈栈顶的位置后再进行返回