## 简介

花指令就是一串垃圾指令，它与程序本身的功能无关，并不影响程序本身的逻辑，但会影响反编译器的正常运行，干扰分析人员的静态分析，从而增加分析难度和分析时间

花指令也可以被用在病毒或木马上，通过加入花指令改变程序的特征码，躲避杀软的扫描，从而达到免杀的目的
## 原理

反汇编算法存在缺陷

反汇编算法主要可以分为两类

- 递归下降算法
- 线性扫描算法

### 1. 递归下降算法

递归下降算法强调控制流的概念，它按照代码可能的执行顺序来反汇编程序，对每条可能的路径都进行扫描，当解码出分支指令后，就将地址记录下来，并分别反汇编各个分支中的指令

这种算法比较灵活，可以避免将代码中的数据作为指令解码

但是通过构造必然条件或互补条件，可以使反汇编出错

IDA Pro 使用的就是递归下降算法

### 2. 线性扫描算法

线性扫描算法从程序入口点开始反汇编，对整个代码段进行扫描，反汇编扫描过程中所遇到的每条指令

这种算法没有对反汇编的内容进行判断，因而无法正确区分代码和数据，导致一些数据也被当成代码来解码，从而导致反汇编出现错误，而这种错误将会影响到下一条指令的正确识别
## 分类

花指令一般分为两类

- 不可执行花指令
- 可执行花指令
### 不可执行花指令

这类花指令虽然被插入到了正常代码的中间，但是它并不会得到执行，这类花指令通常形式为在代码中出现了类似数据的代码，或者 IDA 反编译后为 `JUMPOUT(xxxxx)`

根据反汇编的工作原理，只有花指令同正常指令的前几个字节被反汇编器识别成一组无用字节时，才能破坏反汇编的结果。因此，插入的花指令应当是一些不完整的指令，而这类花指令一般不属于CPU可以识别的操作码，所以需要在上面用跳转跳过这些花指令才能保证程序的正常运行

为了能确保代码正确运行的同时使反汇编出错，该类花指令必须满足两个基本条件

- 垃圾数据必须是某个合法指令的一部分
- 程序运行时，花指令必须位于实际不可执行的代码路径
#### 形式一：插入一个操作码

如果插入的花指令是一个操作码，那么后面程序原本的机器码就会被误认为是这个操作码的操作数，从而导致反汇编引擎的解析错误

**示例**

```
	xor eax, eax
	jz s
	_emit 0x11 nop 0x90
	_emit 0x22
	_emit 0x33
s:
```

由于经过 `xor eax,eax` 后， `ZF` 标志位被置为 1，那 `jz` 这条跳转指令必定会被执行，后面插入的 `0x11` , `0x22` , `0x33` 就会被跳过

但是这样会对 IDA 的正常解析造成影响

**对抗方法**

1. 定位位置
2. 使用 `nop` 指令将多余的字节码去掉，再使用 IDA 分析

#### 形式二：改变堆栈平衡

插入能改变堆栈平衡的汇编代码，同样在这些花指令上面写上跳转指令，虽然花指令不会被执行，但是 IDA 进行解析时会认为该函数堆栈不平衡，从而导致无法反编译

**示例**

```
	xor eax, eax
	jz s
	add esp, 0x11
s:
```

由于经过 `xor eax,eax` 后， `ZF` 标志位被置为 1，那 `jz` 这条跳转指令必定会被执行，后面的汇编指令 `add esp, 0x11` 会修改栈顶位置从而造成堆栈不平衡，但是这句不会被执行到

但是这样同样会对 IDA 的正常解析造成影响

**对抗方法**

1. 定位位置
2. 使用 `nop` 指令将造成堆栈不平衡的汇编代码去掉
#### 形式三：互补跳转

利用 `jz` 和 `jnz` 指令互补跳转，类似直接 `jmp`

**示例**

```
	jz Label
	jnz Labe
	_emit 0x11
Label:
```

此处不管如何 `0x11` 都不会遇到，但会对 IDA 分析造成影响

**对抗方法**

将中间不会遇到的数据全部 `nop` 掉

### 可执行花指令

这类花指令会在程序运行的时候执行

可能执行这些指令没有任何意义，它并不会改变寄存器的值，同时反汇编器也可以正常地反汇编这些指令，但是反编译器无法正确识别

也可能执行这些指令替代了另一些指令的功能，而反编译器无法正确识别

可执行花指令的目的是为了增加静态分析的难度，从而加大逆向分析人员的工作量
#### 形式一：改变堆栈操作

使用特殊的方式将堆栈操作使用不同的方式表示

**示例**

```
push eax
add esp, 4
```

在 32 位下， `push eax` 分为两个步骤：

1. `esp = esp - 4` ，将 `esp` 的值，即栈顶位置减 4
2. 将 `eax` 的值放入 `esp` 地址中，即将 `eax` 的值入栈

在之后一般应该有一句 `pop` 指令将栈中的值出栈到 `eax` 寄存器中，再将 `esp` 寄存器的值加 4，即栈顶位置回到原位，从而保证堆栈平衡

但是这里使用 `add esp, 4` 实现 `esp = esp + 4` ，从而取代 `pop` 指令的部分功能，恢复堆栈平衡，使程序能够正常运行

但是 IDA 无法正常识别这种操作

**对抗方法**

使用 `pop` 指令替换回去，但是要保证前后功能一致

#### 形式二：使用多次跳转

利用 `call` 指令或 `jmp` 指令来增加程序执行流程的复杂度

**对抗方法**

将中间的跳转 `nop` 掉，在最初的跳转处修改跳转地址，直接将跳转地址修改为最终需要跳转的位置
